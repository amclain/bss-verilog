//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module bss_verilog(
    //////////// ADC //////////
    output                      ADC_CONVST,
    output                      ADC_SCK,
    output                      ADC_SDI,
    input                       ADC_SDO,

    //////////// ARDUINO //////////
    inout           [15:0]      ARDUINO_IO,
    inout                       ARDUINO_RESET_N,

    //////////// CLOCK //////////
    input                       FPGA_CLK1_50,
    input                       FPGA_CLK2_50,
    input                       FPGA_CLK3_50,

    //////////// HPS //////////
    // inout                        HPS_CONV_USB_N,
    // output           [14:0]      HPS_DDR3_ADDR,
    // output            [2:0]      HPS_DDR3_BA,
    // output                       HPS_DDR3_CAS_N,
    // output                       HPS_DDR3_CK_N,
    // output                       HPS_DDR3_CK_P,
    // output                       HPS_DDR3_CKE,
    // output                       HPS_DDR3_CS_N,
    // output            [3:0]      HPS_DDR3_DM,
    // inout            [31:0]      HPS_DDR3_DQ,
    // inout             [3:0]      HPS_DDR3_DQS_N,
    // inout             [3:0]      HPS_DDR3_DQS_P,
    // output                       HPS_DDR3_ODT,
    // output                       HPS_DDR3_RAS_N,
    // output                       HPS_DDR3_RESET_N,
    // input                        HPS_DDR3_RZQ,
    // output                       HPS_DDR3_WE_N,
    // output                       HPS_ENET_GTX_CLK,
    // inout                        HPS_ENET_INT_N,
    // output                       HPS_ENET_MDC,
    // inout                        HPS_ENET_MDIO,
    // input                        HPS_ENET_RX_CLK,
    // input             [3:0]      HPS_ENET_RX_DATA,
    // input                        HPS_ENET_RX_DV,
    // output            [3:0]      HPS_ENET_TX_DATA,
    // output                       HPS_ENET_TX_EN,
    // inout                        HPS_GSENSOR_INT,
    // inout                        HPS_I2C0_SCLK,
    // inout                        HPS_I2C0_SDAT,
    // inout                        HPS_I2C1_SCLK,
    // inout                        HPS_I2C1_SDAT,
    // inout                        HPS_KEY,
    // inout                        HPS_LED,
    // inout                        HPS_LTC_GPIO,
    // output                       HPS_SD_CLK,
    // inout                        HPS_SD_CMD,
    // inout             [3:0]      HPS_SD_DATA,
    // output                       HPS_SPIM_CLK,
    // input                        HPS_SPIM_MISO,
    // output                       HPS_SPIM_MOSI,
    // inout                        HPS_SPIM_SS,
    // input                        HPS_UART_RX,
    // output                       HPS_UART_TX,
    // input                        HPS_USB_CLKOUT,
    // inout             [7:0]      HPS_USB_DATA,
    // input                        HPS_USB_DIR,
    // input                        HPS_USB_NXT,
    // output                       HPS_USB_STP,

    //////////// KEY //////////
    input            [1:0]      KEY,

    //////////// LED //////////
    output           [7:0]      LED,

    //////////// SW //////////
    input            [3:0]      SW,

    //////////// GPIO_0, GPIO connect to GPIO Default //////////
    inout           [35:0]      GPIO_0,

    //////////// GPIO_1, GPIO connect to GPIO Default //////////
    inout           [35:0]      GPIO_1
);

//=======================================================
//  REG/WIRE declarations
//=======================================================

// Mock input
wire [7:0] data_in;
wire write_command;
wire write_address_0;
wire write_address_1;
wire write_address_2;
wire write_address_3;
wire write_address_4;
wire write_address_5;
wire write_sv_0;
wire write_sv_1;
wire write_data_0;
wire write_data_1;
wire write_data_2;
wire write_data_3;

// wire clk;
// wire do_encode;

reg [7:0] command;
reg [7:0] address [0:5];
reg [7:0] sv      [0:1];
reg [7:0] data    [0:3];

reg [7:0] out     [0:28];

wire [7:0] input_buffer[0:12];

parameter ESC = 8'h1B;

//=======================================================
//  Structural coding
//=======================================================

assign input_buffer[0]  = command;
assign input_buffer[1]  = address[0];
assign input_buffer[2]  = address[1];
assign input_buffer[3]  = address[2];
assign input_buffer[4]  = address[3];
assign input_buffer[5]  = address[4];
assign input_buffer[6]  = address[5];
assign input_buffer[7]  = sv[0];
assign input_buffer[8]  = sv[1];
assign input_buffer[9]  = data[0];
assign input_buffer[10] = data[1];
assign input_buffer[11] = data[2];
assign input_buffer[12] = data[3];

// assign LED[0] = SW[1] ? !SW[0] : SW[0];

// assign clk = FPGA_CLK1_50;
// assign LED[0] = state;

// always @ (posedge clk)
// begin
//     state <= !state;
// end

// assign GPIO_0[7:0]   = byte[0][7:0];
// assign GPIO_0[15:8]  = byte[1][7:0];
// assign GPIO_0[23:16] = byte[2][7:0];
// assign GPIO_0[35:24] = byte[3][7:0];

// always @(posedge clk)
// begin
//     byte[0] <= !byte[0];
//     byte[1] <= !byte[1];
//     byte[2] <= !byte[2];
//     byte[3] <= !byte[3];
// end

// Mock input
assign data_in[7:0] = ARDUINO_IO[7:0];

assign write_command = ARDUINO_IO[8];
assign write_address_0 = ARDUINO_IO[9];
assign write_address_1 = ARDUINO_IO[10];
assign write_address_2 = ARDUINO_IO[11];
assign write_address_3 = ARDUINO_IO[12];
assign write_address_4 = ARDUINO_IO[13];
assign write_address_5 = ARDUINO_IO[14];
assign write_sv_0 = ARDUINO_IO[15];

always @(
    posedge write_command or
    posedge write_address_0 or
    posedge write_address_1 or
    posedge write_address_2 or
    posedge write_address_3 or
    posedge write_address_4 or
    posedge write_address_5 or
    posedge write_sv_0 or
    posedge write_sv_1 or
    posedge write_data_0 or
    posedge write_data_1 or
    posedge write_data_2 or
    posedge write_data_3
)
begin
    if (write_command) begin
        command <= data_in;
    end else if (write_address_0) begin
        address[0] <= data_in;
    end else if (write_address_1) begin
        address[1] <= data_in;
    end else if (write_address_2) begin
        address[2] <= data_in;
    end else if (write_address_3) begin
        address[3] <= data_in;
    end else if (write_address_4) begin
        address[4] <= data_in;
    end else if (write_address_5) begin
        address[5] <= data_in;
    end else if (write_sv_0) begin
        sv[0] <= data_in;
    end else if (write_sv_1) begin
        sv[1] <= data_in;
    end else if (write_data_0) begin
        data[0] <= data_in;
    end else if (write_data_1) begin
        data[1] <= data_in;
    end else if (write_data_2) begin
        data[2] <= data_in;
    end else if (write_data_3) begin
        data[3] <= data_in;
    end
end

assign GPIO_0[7:0]   = out[0][7:0];
assign GPIO_0[15:8]  = out[1][7:0];
assign GPIO_0[23:16] = out[2][7:0];
assign GPIO_0[31:24] = out[3][7:0];
assign GPIO_1[7:0]   = out[4][7:0];
assign GPIO_1[15:8]  = out[5][7:0];
assign GPIO_1[23:16] = out[6][7:0];
assign GPIO_1[31:24] = out[7][7:0];

reg [5:0] address_is_escaped;
reg [1:0] sv_is_escaped;
reg [3:0] data_is_escaped;
reg checksum_is_escaped;

reg [5:0] address_offset;

always @(*)
begin
    address_offset[0] = 0;
    address_offset[1] = 0;
    address_offset[2] = 0;
    address_offset[3] = 0;
    address_offset[4] = 0;
    address_offset[5] = 0;
    
    out[0] = 8'h02;
    out[1] = command;
    
    if (is_reserved_byte(address[0])) begin
        address_is_escaped[0] = 1'b1;
        out[2 + address_offset[0]] = ESC;
        out[3 + address_offset[0]] = address[0] + 8'h80;
    end else begin
        address_is_escaped[0] = 1'b0;
        out[2 + address_offset[0]] = address[0];
    end
    
    if (address_is_escaped[0]) begin
        address_offset[1] = address_offset[1] + 1;
        address_offset[2] = address_offset[2] + 1;
        address_offset[3] = address_offset[3] + 1;
        address_offset[4] = address_offset[4] + 1;
        address_offset[5] = address_offset[5] + 1;
    end
    
    if (is_reserved_byte(address[1])) begin
        address_is_escaped[1] = 1'b1;
        out[3 + address_offset[1]] = ESC;
        out[4 + address_offset[1]] = address[1] + 8'h80;
    end else begin
        address_is_escaped[1] = 1'b0;
        out[3 + address_offset[1]] = address[1];
    end
    
    if (address_is_escaped[1]) begin
        address_offset[2] = address_offset[2] + 1;
        address_offset[3] = address_offset[3] + 1;
        address_offset[4] = address_offset[4] + 1;
        address_offset[5] = address_offset[5] + 1;
    end
    
    if (is_reserved_byte(address[2])) begin
        address_is_escaped[2] = 1'b1;
        out[4 + address_offset[2]] = ESC;
        out[5 + address_offset[2]] = address[2] + 8'h80;
    end else begin
        address_is_escaped[2] = 1'b0;
        out[4 + address_offset[2]] = address[2];
    end
    
    if (address_is_escaped[2]) begin
        address_offset[3] = address_offset[3] + 1;
        address_offset[4] = address_offset[4] + 1;
        address_offset[5] = address_offset[5] + 1;
    end
    
    if (is_reserved_byte(address[3])) begin
        address_is_escaped[3] = 1'b1;
        out[5 + address_offset[3]] = ESC;
        out[6 + address_offset[3]] = address[3] + 8'h80;
    end else begin
        address_is_escaped[3] = 1'b0;
        out[5 + address_offset[3]] = address[3];
    end
    
    if (address_is_escaped[3]) begin
        address_offset[4] = address_offset[4] + 1;
        address_offset[5] = address_offset[5] + 1;
    end
    
    if (is_reserved_byte(address[4])) begin
        address_is_escaped[4] = 1'b1;
        out[6 + address_offset[4]] = ESC;
        out[7 + address_offset[4]] = address[4] + 8'h80;
    end else begin
        address_is_escaped[4] = 1'b0;
        out[6 + address_offset[4]] = address[4];
    end
    
    if (address_is_escaped[4]) begin
        address_offset[5] = address_offset[5] + 1;
    end
    
    if (is_reserved_byte(address[5])) begin
        address_is_escaped[5] = 1'b1;
        out[7 + address_offset[5]] = ESC;
        out[8 + address_offset[5]] = address[5] + 8'h80;
    end else begin
        address_is_escaped[5] = 1'b0;
        out[7 + address_offset[5]] = address[5];
    end
    
    // if (is_reserved_byte(address[1])) begin
    //     address_is_escaped[1] = 1'b1;
        
    //     if (address_is_escaped[0]) begin
    //         out[4] = ESC;
    //         out[5] = address[1] + 8'h80;
    //     end else begin
    //         out[3] = ESC;
    //         out[4] = address[1] + 8'h80;
    //     end
    // end else begin
    //     address_is_escaped[1] = 1'b0;
        
    //     if (address_is_escaped[0]) begin
    //         out[4] = address[1];
    //     end else begin
    //         out[3] = address[1];
    //     end
    // end
end

function is_reserved_byte;
input [7:0] byte;
begin
    if (
        byte == 8'h02 ||
        byte == 8'h03 ||
        byte == 8'h06 ||
        byte == 8'h15 ||
        byte == 8'h1B
    ) begin
        is_reserved_byte = 1'b1;
    end else begin
        is_reserved_byte = 1'b0;
    end
end
endfunction

endmodule
